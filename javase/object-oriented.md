### 面向对象vs面向过程

面向过程：把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可

面向对象：将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题

### 封装

访问控制：public  protected  default  private

包：package

### 继承

继承：继承有访问权限的字段及方法，包括静态字段及静态方法

子类方法所声明的访问控制级别不能比父类的限制大

子类方法所声明的返回类型必须是父类方法所声明的返回类型或其子类

子类方法所声明的抛出异常必须是父类方法所声明的抛出异常或其子类，也可不声明异常

方法签名：方法名+参数列表，重写方法签名相同，重载方法签名不同

复用的实现方式：继承    组合   代理（委托）

this()和super()必须放在构造函数第一行，但两者不能同时用，this()调用重载构造函数中也有super()调用

初始化顺序:

1. 分配空间，初始化为零(基本数据类型赋值为0，引用类型赋值为null)
2. 父类静态初始化
3. 子类静态初始化
4. 父类实例初始化
5. 父类构造器
6. 子类实例初始化
7. 子类构造器

### 多态

同一操作作用于不同对象，有不同的解释，产生不同的结果

多态是一种运行期特性，Java中的重写是多态的体现。也有人提出重载是一种静态多态，倾向于重载不是多态

只有普通的方法调用可以是多态的

将一个方法调用和一个方法主体关联起来称作绑定，若绑定发生在程序运行前，叫做前期绑定

后期绑定，意味着在运行时根据对象的类型进行绑定。编译器仍然不知道对象的类型，但方法调用机制能找到正确的方法并调用

除了 static 和 final 方法（private 方法也是隐式的 final）外，其他所有方法都是后期绑定

### 接口

方法默认 public abstract

字段默认 public static final

默认方法 default

静态方法 public static

内部类为 public static

JDK9:

静态方法 private static

私有方法 private

### 内部类

内部类自动拥有对其外部类所有成员的访问权，内部类对象会秘密地捕获一个指向那个外部类对象的引用

Class.this   Class.super  Object.new

内部类使用到外部的对象必须是final或等同与final的

普通内部类不能有static方法  不能有static内部类  static字段必须可以被解析为编译常量  

从一个内部类继承，指向外围类对象的引用必须被初始化  

```java
class Inherit extends Outer.Inner{
    Inherit(Outer oc) {
        oc.super();
    }
}
```

普通内部类、静态内部类、局部内部类、匿名内部类、lambda多次调用都是同一个Class对象，lambda并不会生成class文件

### Object

#### equals  hashcode

equals特性

1. 反身性：x.equals(x) = true 
2. 对称性：x.equals(y) = y.equals(x)
3. 传递性:   x.equals(y) & y.equals(z) ==> x.equals(z)
4. 一致性：多次调用x.equals(y)结果相同
5. x.equals(null) === false

hashCode() 和 equals() 必须能够允许类型在hash数据结构中正常工作

散列码应该是均匀的，更关注速度而非唯一

多字段对象：Objects.hash()      单字段对象：Objects.hashcode()

散列表中的槽位slot通常被称为桶位bucket，为了使散列表分布更均匀，需要选择合适的散列通容量。

事实证明，质数实际上并不是散列桶的理想容量。近来，Java的散列桶都使用2的n次方。

现代处理器中除法与求余数是最慢的操作。当length为2的n次方时，hash & (length - 1) == hash % length 

#### clone

必须实现了Cloneable的类才能clone

浅拷贝：默认clone方法会创建一个新对象，但对象内的变量不会clone

深拷贝：创建一个新对象，并且原对象内非基本类型的变量也会clone

#### methods

### 枚举

编译器为你创建一个继承自java.lang.Enum的final类，但其中可以有抽象方法，通过实例来实现抽象方法

所有的实例都是public static final的

字段或方法必须定义在enum实例之后

enum作为内部类时是static的

enum不能和泛型结合

enum实现了Comparable接口，比较实例的ordinal

enum实现了Serializable接口，但JVM对枚举的序列化和反序列化做了限制，序列化时仅将实例name输出到结果中，反序列化时通过name找到对应实例，不会破坏单例

类加载是线程安全时，枚举也是线程安全的

EnumSet

EnumMap

### 方法传值策略

编程语言中需要进行方法间的参数传递(实参传递给形参)，这个传递的策略叫做求值策略，基本分为严格求值和非严格求值，大多数编程语言对函数参数传递采用的都是严格求值

- 传值调用（值传递）
    - 在传值调用中，实际参数先被求值，然后其值通过复制，被传递给被调函数的形式参数。改变并不会改变实际参数的值。
- 传引用调用（引用传递）
    - 在传引用调用中，传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。改变对于调用者来说是可见的。
- 传共享对象调用（共享对象传递）
    - 传共享对象调用中，先获取到实际参数的地址，然后将其复制，并把该地址的拷贝传递给被调函数的形式参数。因为参数的地址都指向同一个对象，我们也称之为"传共享对象"，如果在被调函数中改变了形式参数的值，调用者是可以看到这种变化的。

**Java中使用的求值策略就是传共享对象调用，也就是说，Java会将对象的地址的拷贝传递给被调函数的形式参数。**只不过"传共享对象调用"这个词并不常用，所以Java社区的人通常说"Java是传值调用"，因为传共享对象调用其实是传值调用的一个特例。


