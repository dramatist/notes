垃圾收集器，也是内存管理器

### 哪些内存需要回收？ 

堆和方法区

程序计数器、方法栈当方法或线程结束时，内存自然跟着回收

### 对象存活状态

引用计数：有环的时候导致内存泄漏、内存溢出，主流Java虚拟机都未采用该算法

可达性分析算法：通过一系列成为GC roots的根对象作为起始节点集，根据引用关系向下搜索，走过的路径成为引用链，如果一个对象不在任何引用链中，即从GC roots到这个对象不可达，证明此对象不能被使用

GC roots：

1. 虚拟机栈中引用的对象，即栈帧中的本地变量表
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. JNI引用
5. 虚拟机内部引用，如基本类型的Class对象，常驻的异常对象，还有系统类加载器等
6. 被同步锁(synchronized)持有的对象
7. 反应虚拟机内部情况的JXMBean、JVMTI中注册的回调、本地代码缓存等

要宣告一个对象死亡，需要经过两次标记阶段，如果一个对象不在引用链中则被第一次标记

随后进行一次筛选，判断对象是否有必要执行finalize方法，如果一个对象没有覆盖finalize方法或finalize方法已被虚拟机执行过，虚拟机将这种情况视为没有必要执行，如果对象被判断为需要执行finalize方法，该对象会被放在F-Queue队列中，并在之后由一条由虚拟机创建、低优先级的Finalizer线程去执行它们的finalize方法，但该方法只会被触发执行，但虚拟机不确保会等待它执行结束，避免死循环之类的问题导致其他对象无法回收

最后收集器对F-Queue中的对象进行第二次标记，如果在finalize方法中对象与引用链关联上，那么其不会被回收，否则就被真正回收

任何一个对象的finilize方法只会执行一次，下一次回收时若已经执行过，则finilize方法不会被再次执行

#### 引用

![image-20210208153701833](../.image/image-20210208153701833.png?lastModify=1618403488)

##### StrongReference

我们平时开发中new一个对象出来，这种引用便是强引用。无论任何情况，垃圾收集器永远不会回收被强引用的对象 

JVM 系统采用 Finalizer 来管理每个强引用对象 , 并将其被标记要清理时加入ReferenceQueue,

##### SoftReference

只被软引用关联的对象，当内存足够的时候，GC的时候并不会被回收，当且只当内存不够时才会被GC进行二次回收，若回收后内存仍不够，才会抛出内存溢出异常

##### WeakReference

只被弱引用关联的对象，下一次GC的时候会进行回收

##### PhantomReference

一个对象是否有虚引用存在，完全不影响其生存时间，也无法通过虚引用获得一个对象实例，为一个对象设置虚引用的唯一目的只是为了能在这个对象被垃圾回收器回收时收到一个系统通知

#### 方法区回收

废弃常量和不再使用的类1型

类型不再被使用：

1. 该类所有的对象都已经被回收
2. 加载该类的类加载器已经被回收
3. 该类对应的Class对象没有在任何地方被引用

### 垃圾收集算法

引用计数式垃圾收集和追踪式垃圾收集，也被称为直接垃圾收集和间接垃圾收集，主流Java虚拟机都未实现引用计数式垃圾收集

大多垃圾收集器遵循分代收集理论

1. 弱分代假说：绝大多数对象都是朝生夕死的
2. 强分代假说：熬过越多次垃圾收集的对象就越难消亡
3. 跨代引用假说：跨代引用相对于同代引用仅占极少数

收集器应该将堆划分不同区域，将回收对象根据其年龄分配到不同区域，一般分为新生代和老年代，在新生代中，每次垃圾收集都有大批对象死去，而每次回收存活的少量对象，逐步晋升到老年代

根据第三条假说，不必再为少量的跨代引用扫描整个老年代，只需在新生代建立一个全局的数据结构(被称为记忆集)，这个结构把老年代分为若干块，标识出老年代哪一块内存存在跨代引用，此后发生Miner GC时，只有包含跨代引用的小块内存的对象被加入到GC roots，相比扫描整个老年代划算的多

* 部分收集 Partial GC：目标不是完成收集整个堆的垃圾收集
    * 新生代收集 Miner GC / Young GC：目标只是新生代
    * 老年代收集 Major GC / Old GC：目标只是老年代，目前只有CMS有单独收集老年代的行为
    * 混合收集 Mixed GC：目标是收集整个新生代以及部分老年代的垃圾收集器，目前只有G1会有这种行为
* 整堆收集 Full GC：收集整个堆和方法区的垃圾收集

#### 标记清除算法

Mark-Sweep，标记出需要回收的对象，统一回收

缺点：

1. 执行效率不稳定，如果堆中有大量数据需要回收，需要大量标记和清除动作
2. 内存碎片

#### 标记复制算法

基于半区复制算法：将可用内存分为划分为两块，每次只使用其中一块，垃圾收集时，将回收后的可用对象复制到另一块区域中，再将原有区域全部清理，对于大多数对象都是可回收的情况，复制操作极少，且分配内存不必考虑碎片问题，只需移动堆顶指针，但缺陷就是只能使用一半内存空间，目前大多虚拟机采用该算法回收新生代

Appel式回收在其基础上更加优化，将新生代分为Eden区和两块Survivor区，比例为8:1:1，每次分配内存只使用Eden和一块Survivor，发生垃圾收集时，将存活对象复制到Survivor区中，当Survivor区不足以容纳一次Miner GC之后存活的对象，需要依赖其他区域进行分配担保(Handle Promotion)

#### 标记整理算法

对于大多数对象都是存活的情况，标记复制算法效率会降低，所以老年代一般不使用

标记整理算法在标记完成后，将存活对象向内存一端移动，然后清理掉边界外的内存

大量对象存活，移动对象要更新引用，Stop The World，ZGC和Shenandoah使用读屏障，实现了整理和用户线程并发执行

吞吐量的实质是Mutator(赋值器，可以理解为使用垃圾收集的用户程序)与收集器的效率总和

CMS更关注延迟使用标记清除，Parallel Scavenge更关注吞吐量使用标记整理

7、8：ParallelGC

9+：G1

#### Serial GC 和 Parallel GC

Serial GC：对年轻代使用标记复制算法，对老年代使用标记清除整理算法，只适用于几百兆的堆，且是单核CPU时比较有限

Parallel GC：对年轻代使用标记复制算法，对老年代使用标记清除整理算法，-XX:ParallelGCThreads配置GC线程数，默认为CPU核心数

CMS：对年轻代使用并行STW的标记复制算法，对老年代使用并发标记清除算法，避免在老年代出现长时间的卡顿，不对老年代整理，通过空闲列表free list来管理内存空间的回收，在标记清除阶段，大部分工作和工作线程一起并发执行，CMS使用的线程数通常为CPU核心数的1/4，六个阶段：

1. Initial Mark
2. Concurrnet Mark
3. Concurrent Preclean
4. Final Mark
5. Concurrent Sweep
6. Concurrent Reset



### G1

Garbage-First，把GC STW停顿的时间和分布是可配置和可预期的，不区分老年代和年轻代，，而是划分为通常为2048个可以存放对象的小堆区

### ZGC



### JVM参数

以-开头为标准参数，所有JVM要实现并保证向后兼容，如-server，-client

以-D 设置系统属性

以-X开头为非标准参数，不保证向后兼容和所有JVM都实现，使用java -X查看可用参数

以-XX:开头，为非稳定参数，用于控制JVM行为，和具体JVM实现有关，随时可能在下个版本取消

分类：

* 系统属性参数
* 运行模式参数
* 堆内存设置参数
* GC设置参数
* 分析诊断参数
* JavaAgent参数

-Xms  堆内存初始大小，指定的内存大小，并不是操作系统实际分配的初始值，而是GC先规划好，用到才分配

-Xmx  最大堆内存，默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到

​	 	  -Xms的最小限制

-Xmn  年轻代大小，等价于 -XX:NewSize，使用G1垃圾收集器不应该设置该选项。官方建议设置为 -Xmx 的 1/2 ~ 1/4

-Xss    设置每个线程栈的字节数

-XX:NewRatio  设置年轻代(包括Eden和两个Survivor区)与年老代的比值

-XX:SurvivorRatio  设置年轻代中Eden区与Survivor区的大小比值

-XX:MaxMetaspaceSize  设置元空间最大值

-XX:MetaspaceSize  设置元空间初始值

-XX:MinMetaspaceFreeRatio  -XX:MaxMetaspaceFreeRatio 设置元空间最小或最大剩余容量的百分比

-XX:MaxDirectMemorySize，系统可以使用的最大堆外内存，默认与Java堆最大值一致

-XX:+HeapDumpOnOutOfMemoryError

-XX:HeapDumpPath

-XX:+UseG1GC:使用 G1 垃圾回收器 

-XX:+UseConcMarkSweepGC:使用 CMS 垃圾回收器 

-XX:+UseSerialGC:使用串行垃圾回收器 

-XX:+UseParallelGC:使用并行垃圾回收器

-XX:+UnlockExperimentalVMOptions -XX:+UseZGC

-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC

-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1506，远程调试

### 命令行工具

| 命令      | 说明                          | 常用选项                |
| --------- | ----------------------------- | ----------------------- |
| jps/jinfo | 查看Java进程                  |                         |
| jstat     | 查看JVM内部GC信息             | -gc   -gcutil       pid |
| jmap      | 查看heap或类占用空间统计      | -heap   -histo   pid    |
| jstack    | 查看线程信息                  | pid -l                  |
| jcmd      | 执行JVM相关分析命令(整合命令) | pid help                |
| jhsdb     |                               |                         |





