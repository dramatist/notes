行为型模式：类和对象之间的交互

### 观察者模式

在对象之间定义一对多的的依赖，当一个对象改变时，依赖的对象会收到通知，被依赖的对象称为被观察者，依赖的对象称为观察者

同步阻塞、异步非阻塞、进程间、进程内都可

EventBus事件总线：Google Guava EventBus就是一个比较出名的EventBus框架，它既支持同步阻塞，也支持异步非阻塞

### 模版模式

在一个方法中定义算法骨架，将某些步骤推迟到子类实现

增强复用和扩展

例如：InputStream、AbstractList#addAll、Servlet#services、Junit

回调：双向调用，A调用B，B在执行中执行A发送给B的回调函数，这种机制就叫回调

Spring大多Template类都采用回调

### 策略模式

定义一组类，使类的方法变化独立于使用它们的类，解耦策略的定义、创建和实现

策略定义：一个策略接口多个策略实现

策略创建：可考虑工厂

策略使用：运行时动态确定

对于工厂的if-else，可以使用注解、配置或者IOC解耦

### 职责链模式

将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求

在职责链模式中，多个接收对象依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条，所以叫作职责链模式

职责链模式有两种变体：

1. 链条上某个处理器能够处理，就不会继续往下处理
2. 链条上所有处理器都处理一遍

Servlet Filter、Spring Interceptor

### 状态模式

主要用来实现有限状态机 Finite State Machine，其他方法还有分支逻辑法，查表法等

状态、事件(转移条件)、动作

状态模式先定义接口声明所有事件，再为每个状态实现该接口，每个实现函数就是动作

### 迭代器模式

遍历集合对象，将集合的遍历从集合中拆分出来，放到迭代器类中，指责更加单一

使用迭代器遍历时不能增删，否则可能出现元素重复遍历或无法遍历，所以增删元素后要让遍历报错

ArrayList采用modCount

### 备忘录模式

在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象外保存，以便对象恢复先前的状态

用在防丢失、撤销、恢复等场景

常用实现：用栈保存快照

### 命令模式

将命令(函数)封装成对象，这样可以使用不同的命令参数话其他对象，并能够支持命令的排队执行、记录日志、撤销等

### 解释器模式

解释器为一个语言定义语法，并定义一个解释器处理语法，主要用于编译器、规则引擎、正则等

Antlr

### 中介模式



